
/*
rewrite sizeof_array:
  sizeof([ i64 ?n x lltype ?t ]) = bvmul(i64 ?n, sizeof(lltype ?t))
*/

/**********************************************
 * Generally useful rules about getelementptr 
 *************************************/

rewrite sizeof_ptr:
  sizeof(pointer_type(lltype ?t)) = ptr_size()
;

/* the size of the array doesn't matter for jumping
 * (moreover, ?n here might be a size given by LLVM's type system, which
 *  doesn't keep track of array's sizes unless they are constant)
 * and the rules are the same for arrays and pointers
 * so we might as well care only about pointers
 */
equiv gep_array:
  bool ?f * pointer(eltptr(i64 ?p,lltype [i64 ?n x lltype ?at],lljump ?j), lltype ?t, llmem ?v)
  <=> bool ?f * pointer(eltptr(i64 ?p,pointer_type(lltype ?at),lljump ?j), lltype ?t, llmem ?v)
;
equiv inconsistent nobacktrack gep_end:
  bool ?f * pointer(eltptr(i64 ?y,lltype ?t, jump_end()),lltype ?tt, llmem ?v)
  <=> bool ?f * pointer(i64 ?y, lltype ?tt, llmem ?v)
;
equiv inconsistent nobacktrack pointer_gep0:
  bool ?f * pointer(eltptr(i64 ?p, pointer_type(lltype ?pt), jump(i64 0,lljump ?j)),lltype ?t, llmem ?v)
  <=> bool ?f * pointer(eltptr(i64 ?p,lltype ?pt,lljump ?j),lltype ?t,llmem ?v)
;
equiv inconsistent nobacktrack gep_struct(lltype _st, i64 _i):
 bool ?f * pointer(eltptr(i64 ?p, lltype _st, jump(i64 _i,lljump ?j)),lltype ?t, llmem ?v)
  <=> bool ?f * pointer(eltptr(i64 %p + offset(lltype _st,i64 _i),field_type(lltype _st,i64 _i),lljump ?j),lltype ?t,llmem ?v)
;

rule nobacktrack unfold_struct(lltype _st, i64 _i):
  bool ?f | bool ?l * pointer(i64 ?x, lltype _st, llmem ?v)
  |- pointer(i64 %p + offset(lltype _st, i64 _i), field_type(lltype _st, i64 _i), llmem ?w) * bool ?r
if
  bool ?f | bool ?l * exploded_struct(i64 ?x, lltype _st, llmem ?v)
  |- pointer(i64 %p + offset(lltype _st, i64 _i), field_type(lltype _st, i64 _i), llmem ?w) * bool ?r
;

rule nobacktrack unfold_struct_inner(lltype _st, i64 _i):
  bool ?f | bool ?l * pointer(i64 ?x, lltype _st, llmem ?v)
  |- pointer(i64 ?y, lltype ?t, llmem ?w) * bool ?r
with
  purecheck (i64 ?x + offset(lltype _st, i64 _i)) <=u i64 ?y;
  purecheck (i64 ?y + sizeof(lltype _st)) <=u i64 ?x
if
  bool ?f | bool ?l * exploded_struct(i64 ?x, lltype _st, llmem ?v)
  |- pointer(i64 ?y, lltype ?t, llmem ?w) * bool ?r
;

/*************************************
 * Simple subtraction rules 
 *************************************/

rule nobacktrack read:
 bool ?f | bool ?l |-  as(i32 ?x) = as(i32 ?y) * bool ?r
if
 bool ?f | bool ?l |- i32 ?x = i32 ?y * bool ?r
;

/* match malloc first
 * usually, ?n below will be a constant and ?m a logical variable,
   so better instantiate ?m as soon as possible */
rule nobacktrack remove_malloced:
 bool ?f | bool ?l * malloced(i64 ?mb,i64 ?n) |- malloced(i64 ?mb,i64 ?m) * bool ?r
if
 bool ?f * malloced(i64 ?mb,i64 ?n) |  bool ?l |- i64 ?n = i64 ?m * bool ?r
;

rule nobacktrack ptr_same_root_same_type:
 bool ?f | bool ?l * pointer(i64 ?x,lltype ?t,llmem ?v) |- pointer(i64 ?x,lltype ?t,llmem ?w) * bool ?r
if
 bool ?f * pointer(i64 ?x,lltype ?t,llmem ?v) | bool ?l |- llmem ?w = llmem ?v * bool ?r
;


/*************************************
 * rules for contradictions 
 *************************************/

/*
  If we have an assumption of a pointer
  for null then we have a contradiction.
 */
rule inconsistent nobacktrack pointer_nil_contradiction:
  bool ?f | bool ?l * pointer(NULL(),lltype ?t,llmem ?v) |- bool ?r
if
;

/* same for malloc */
rule inconsistent nobacktrack malloced_nil_contradiction: 
  bool ?f | bool ?l * malloced(NULL(),i64 ?s) |- bool ?r
if
;

/**************************************
 *  Rules for failed proofs
 **************************************/

/*
  If we need to prove that pointer exists for null
  then we are going to fail, unless we can find 
  a contradiction.
 */
rule nobacktrack pointer_nil_failed :
  bool ?f | bool ?l |- pointer(NULL(),lltype ?t,llmem ?v) * bool ?r
if
  bool ?f | bool ?l |- pointer(NULL(),lltype ?t,llmem ?v) * False * bool ?r
;

rule nobacktrack pointer_not_null :
  bool ?f | bool ?l * pointer(i64 ?x,lltype ?t,llmem ?v) |- i64 ?x!=NULL() * bool ?r
if
  bool ?f | bool ?l * pointer(i64 ?x,lltype ?t,llmem ?v) |- bool ?r
;

rule nobacktrack pointer_different :
  bool ?f | bool ?l * pointer(i64 ?x,lltype ?t,llmem ?v) * pointer(i64 ?y,lltype ?tt,llmem ?vv) |- i64 ?x!=i64 ?y * bool ?r
if
  bool ?f | bool ?l * pointer(i64 ?x,lltype ?t,llmem ?v) * pointer(i64 ?y,lltype ?tt,llmem ?vv) |- bool ?r
;

/*
rule pointer_same_fail :
  pointer(?x,?t,?v) * pointer(?x,?tt,?vv) | |-
where
  sizeof(?t) != NULL() pureguard;
  sizeof(?tt) != NULL() pureguard
if
*/

/* TODO: convert

rule array_extract_first_elt:
  | pointer(?x, array_type(?n, ?t), ?v)
  |- pointer(?x, ?t, ?w)
if
  | pointer(?x, ?t, select(?v, bv_const("64", "0"))) *
  pointer(eltptr(?x, pointer_type(?t), jump(bv_const("64", "1"), jump_end())),
          array_type(bvsub.64(?n,bv_const("64", "1")), ?t),
          array_right_shift(?v,bv_const("64","1")))
 |- pointer(?x, ?t, ?w)

rule array_extract_elt:
  | pointer(?x, array_type(?n, ?t), ?v)
 |- pointer(eltptr(?x, pointer_type(?t), jump(?o, jump_end())), ?t, ?w)
without
  ?o = NULL()
where
  !bvult(?o,?n) pureguard
if
  | pointer(?x, array_type(?o, ?t), ?v)
  * pointer(?y, ?t, select(?v, ?o))
  * pointer(eltptr(?x,pointer_type(?t),jump(bvadd.64(?o,bv_const("64","1")),jump_end())),
            array_type(bvsub.64(?n,bvadd.64(?o,bv_const("64", "1"))), ?t),
            array_shift_right(?v,bvadd.64(?o,bv_const("64","1"))))
 |- pointer(?y, ?t, ?w)

equiv empty_array:
  pointer(?x, array_type(bv_const("64", "0"), ?t), ?v) <=> ?x = ?x

equiv merge_pointer_array:
 ?o = sizeof(?t) =>
   pointer(?x, ?t, ?v1)
 * pointer(bvadd.64(?x,?o),
           array_type(?m, ?t), ?v)
 <=> pointer(?x, array_type(bvadd.64(?m,bv_const("64", "1")), ?t),
             store(array_shift_left(?v,bv_const("64", "1")), bv_const("64", "0"), ?v1))

equiv merge_array_pointer_array:
    pointer(?x, array_type(?o, ?t), ?v)
  * pointer(eltptr(?x, pointer_type(?t), jump(?o, jump_end())), ?t, ?vo)
  * pointer(eltptr(?x,pointer_type(?t),jump(bvadd.64(?o,bv_const("64","1")),jump_end())),
            array_type(bvsub.64(?n,bvadd.64(?o,bv_const("64", "1"))), ?t),
            array_shift_right(?v,bvadd.64(?o,bv_const("64","1"))))
  <=>
  pointer(?x, array_type(?n, ?t), store(?v,?o,?vo))


equiv pointer_getelementptr_i8any:
  pointer(eltptr(?x,pointer_type(integer_type("8")),jump(?n,?j)),?t,?v)
  <=> pointer(eltptr(bvadd.64(?x,?n),?pt,?j),?t,?v)
without ?n = NULL()

equiv pointer_getelementptr1:
  pointer(eltptr(?x,pointer_type(?pt),jump(bv_const("64", "1"),?j)),?t,?v)
  <=> pointer(eltptr(bvadd.64(?x,sizeof(?pt)),?t,?j),?t,?v)

equiv pointer_getelementptr_any:
  pointer(eltptr(?x,pointer_type(?pt),jump(?n,?j)),?t,?v)
  <=> pointer(eltptr(bvadd.64(?x,bvmul.64(?n,sizeof(?pt))),?pt,?j),?t,?v)
without ?n = NULL()

equiv merge_array_pointer:
   pointer(?x, array_type(?s, ?t), ?v)
 * pointer(bvadd.64(?x,bvmul.64(?s,sizeof(?t))),?t,?vp)
 <=> pointer(?x,array_type(bvadd.64(?s,bv_const("64","1")),?t),store(?v,?s,?vp))

equiv merge_array_array:
   pointer(?x, array_type(?s, ?t), ?v)
 * pointer(bvadd.64(?x,bvmul.64(?s,sizeof(?t))),array_type(?s2,?t),?w)
 <=> pointer(?x,array_type(bvadd.64(?s,?s2),?t),array_merge(?v,?s,?w))
*/

rule remove_array:
 bool ?f | bool ?l * pointer(i64 ?x, array_type(i64 ?m, lltype ?t), llmem ?v)
 |- pointer(i64 ?x, array_type(i64 ?n, lltype ?t), llmem ?w) * bool ?r
with
  purecheck i64 ?m = i64 ?n
if
 pointer(i64 ?x, array_type(i64 ?m, lltype ?t), llmem ?v) * bool ?f | bool ?l
 |- llmem ?v = llmem ?w * bool ?r
;

rule array_remove_same_size_l:
 bool ?f | bool ?l * pointer(i64 ?x, lltype [i64 ?s x lltype i8], llmem ^v)
 |- pointer(i64 ?x, lltype ?t, llmem ?w) * bool ?r
with
  fresh llmem ^v in bool ?f;
  fresh llmem ^v in bool ?l;
  fresh llmem ^v in bool ?r;
  purecheck sizeof(lltype ?t) = i64 ?s
if
 bool ?f * pointer(i64 ?x, lltype [i64 ?s x lltype i8], llmem ^v) | bool ?l
 |- llmem ^v = llmem ?w * bool ?r
;
rule array_remove_same_size_r:
 bool ?f | bool ?l * pointer(i64 ?x, lltype ?t, llmem ?w)
 |- pointer(i64 ?x, lltype [i64 ?s x lltype i8], llmem ^v) * bool ?r
with
  fresh llmem ^v in bool ?f;
  fresh llmem ^v in bool ?l;
  fresh llmem ^v in bool ?r
if
 bool ?f * pointer(i64 ?x, lltype ?t, llmem ?w) | bool ?l
 |- sizeof(lltype ?t) = i64 ?s * bool ?r
;

/*
rule ptr_no_overflow:
 | pointer(?x,?t,?v) |-
without
  !bvugt(bvadd.64(?x, sizeof(?t)),?x)
if
 | pointer(?x,?t,?v) * !bvugt(bvadd.64(?x, sizeof(?t)),?x) |-

*/

/*
rule nobacktrack fold_struct(lltype _st):
  bool ?f | bool ?l * exploded_struct_val_pat(i64 ?x, lltype _st)
  |- bool ?r
if
  bool ?f | bool ?l * pointer(i64 ?x, lltype _st, struct_val_pat(lltype _st))
  |- bool ?r
;
*/