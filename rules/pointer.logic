/* pointer_no_val can be generated by abstraction rules */
/*
equiv pval:
  pointer_no_val(?x,?t) <=> pointer(?x,?t,_v)
*/
/*
equiv ival:
  pointer_index64_ult(?x,?n) <=> pointer(?x,integer_type("64"),_v) * !bvule(_v,?n)
*/


/**********************************************
 * Generally useful rules about getelementptr 
 *************************************/

/* the size of the array doesn't matter for jumping
 * (moreover, ?n here might be a size given by LLVM's type system, which
 *  doesn't keep track of array's sizes unless they are constant)
 * and the rules are the same for arrays and pointers
 * so we might as well care only about pointers
 */
equiv eltptr_array:
  pointer(eltptr(?p,array_type(?n, ?at),?j),?t,?v)
  <=> pointer(eltptr(?p,pointer_type(?at),?j),?t,?v)

equiv jump_end:
  pointer(eltptr(?y,?t,jump_end()),?tt,?v) <=> pointer(?y,?tt,?v)

equiv pointer_getelementptr0:
  pointer(eltptr(?p,pointer_type(?pt),jump(bv_const("64", "0"),?j)),?t,?v)
  <=> pointer(eltptr(?p,?pt,?j),?t,?v)

rewrite sizeof_array:
  sizeof(array_type(?n,?t)) = bvmul.64(?n,sizeof(?t))

/*************************************
 * Simple subtraction rules 
 *************************************/

rule ptr_same_root_same_type:
 | pointer(?x,?t,?v) |- pointer(?x,?t,?w)
without
 ?w != ?v
if
 pointer(?x,?t,?v) | |- ?w = ?v

/*
rule ptr_same_root_same_type:
 | pointer_no_val(?x,?t) |- pointer(?x,?t,_v)
where
 _v notincontext
if
 pointer_no_val(?x,?t) | |-
*/

rule remove_malloced:
 | malloced(?mb,?n) |- malloced(?mb,?m)
without
 ?n != ?m
if
 malloced(?mb,?n) | |- ?n = ?m


/*************************************
 * rules for contradictions 
 *************************************/

/*
  If we have an assumption of a pointer
  for null then we have a contradiction.
 */
rule pointer_nil_contradiction:
  pointer(NULL(),?t,?v) | |- 
if

/* same for malloc */
rule malloced_nil_contradiction: 
  malloced(NULL(),?s) | |- 
if


/**************************************
 *  Rules for failed proofs
 **************************************/

/*
  If we need to prove that pointer exists for null
  then we are going to fail, unless we can find 
  a contradiction.
 */
rule pointer_nil_failed :
  | |- pointer(NULL(),?t,?v) 
if
  | |- pointer(NULL(),?t,?v) * False

rule pointer_not_null :
  pointer(?x,?t,?v) | |- ?x!=NULL()
if
  pointer(?x,?t,?v) | |-

rule pointer_different :
  pointer(?x,?t,?v) * pointer(?y,?tt,?vv) | |- ?x!=?y
if
  pointer(?x,?t,?v) * pointer(?y,?tt,?vv) | |-

/*
rule pointer_same_fail :
  pointer(?x,?t,?v) * pointer(?x,?tt,?vv) | |-
where
  sizeof(?t) != NULL() pureguard;
  sizeof(?tt) != NULL() pureguard
if
*/


rule array_extract_first_elt:
  | pointer(?x, array_type(?n, ?t), ?v)
  |- pointer(?x, ?t, ?w)
if
  | pointer(?x, ?t, select(?v, bv_const("64", "0"))) *
  pointer(eltptr(?x, pointer_type(?t), jump(bv_const("64", "1"), jump_end())),
          array_type(bvsub.64(?n,bv_const("64", "1")), ?t),
          array_right_shift(?v,bv_const("64","1")))
 |- pointer(?x, ?t, ?w)

rule array_extract_elt:
  | pointer(?x, array_type(?n, ?t), ?v)
 |- pointer(eltptr(?x, pointer_type(?t), jump(?o, jump_end())), ?t, ?w)
without
  ?o = NULL()
where
  !bvult(?o,?n) pureguard
if
  | pointer(?x, array_type(?o, ?t), ?v)
  * pointer(?y, ?t, select(?v, ?o))
  * pointer(eltptr(?x,pointer_type(?t),jump(bvadd.64(?o,bv_const("64","1")),jump_end())),
            array_type(bvsub.64(?n,bvadd.64(?o,bv_const("64", "1"))), ?t),
            array_shift_right(?v,bvadd.64(?o,bv_const("64","1"))))
 |- pointer(?y, ?t, ?w)

equiv empty_array:
  pointer(?x, array_type(bv_const("64", "0"), ?t), ?v) <=> ?x = ?x

equiv merge_pointer_array:
 ?o = sizeof(?t) =>
   pointer(?x, ?t, ?v1)
 * pointer(bvadd.64(?x,?o),
           array_type(?m, ?t), ?v)
 <=> pointer(?x, array_type(bvadd.64(?m,bv_const("64", "1")), ?t),
             store(array_shift_left(?v,bv_const("64", "1")), bv_const("64", "0"), ?v1))

equiv merge_array_pointer_array:
    pointer(?x, array_type(?o, ?t), ?v)
  * pointer(eltptr(?x, pointer_type(?t), jump(?o, jump_end())), ?t, ?vo)
  * pointer(eltptr(?x,pointer_type(?t),jump(bvadd.64(?o,bv_const("64","1")),jump_end())),
            array_type(bvsub.64(?n,bvadd.64(?o,bv_const("64", "1"))), ?t),
            array_shift_right(?v,bvadd.64(?o,bv_const("64","1"))))
  <=>
  pointer(?x, array_type(?n, ?t), store(?v,?o,?vo))

equiv pointer_getelementptr_i8any:
  pointer(eltptr(?x,pointer_type(integer_type("8")),jump(?n,?j)),?t,?v)
  <=> pointer(eltptr(bvadd.64(?x,?n),?pt,?j),?t,?v)
without ?n = NULL()

equiv pointer_getelementptr1:
  pointer(eltptr(?x,pointer_type(?pt),jump(bv_const("64", "1"),?j)),?t,?v)
  <=> pointer(eltptr(bvadd.64(?x,sizeof(?pt)),?t,?j),?t,?v)

equiv pointer_getelementptr_any:
  pointer(eltptr(?x,pointer_type(?pt),jump(?n,?j)),?t,?v)
  <=> pointer(eltptr(bvadd.64(?x,bvmul.64(?n,sizeof(?pt))),?pt,?j),?t,?v)
without ?n = NULL()

equiv merge_array_pointer:
   pointer(?x, array_type(?s, ?t), ?v)
 * pointer(bvadd.64(?x,bvmul.64(?s,sizeof(?t))),?t,?vp)
 <=> pointer(?x,array_type(bvadd.64(?s,bv_const("64","1")),?t),store(?v,?s,?vp))

equiv merge_array_array:
   pointer(?x, array_type(?s, ?t), ?v)
 * pointer(bvadd.64(?x,bvmul.64(?s,sizeof(?t))),array_type(?s2,?t),?w)
 <=> pointer(?x,array_type(bvadd.64(?s,?s2),?t),array_merge(?v,?s,?w))


rule remove_array:
 | pointer(?x, array_type(?m, ?t), ?v)
 |- pointer(?x, array_type(?n, ?t), ?w)
where ?m = ?n pureguard
if
 pointer(?x, array_type(?m, ?t), ?v) |
 |- ?v = ?w

rule remove_same_size:
 | pointer(?x, array_type(?s, integer_type("8")), _v)
 |- pointer(?x, ?t, ?w)
without
 ?t = array_type(?as,?ta)
where
  _v notincontext;
  sizeof(?t) = ?s pureguard
if
 | pointer(?x, ?t, _v)
 |- pointer(?x, ?t, ?w)

rule array_remove_same_size:
 | pointer(?x, ?t, ?w)
 |- pointer(?x, array_type(?s, integer_type("8")), _v)
without
 ?t = array_type(?as,?ta)
where
  _v notincontext;
  sizeof(?t) = ?s pureguard
if
 | pointer(?x, ?t, ?w)
 |- pointer(?x, ?t, _v)
