/*************************************
 * Simple subtraction rules 
 *************************************/

rule pointer_getelementptr_deref:
| pointer(?p,pointer_type(?tp),?vp) * !eltptr(?x,?p,jump_ptr(numeric_const("0"),?j))
|- pointer(?x,?t,?v)
without
  ?p=?x
if
| pointer(?p,pointer_type(?tp),?vp) * !eltptr(?x,?vp,?j) |- pointer(?x,?t,?v)

/*
rule prout_getelementptr_deref:
| pointer(?p,named_type("struct.prout"),?vp) * !eltptr(?x,?p,jump_named("struct.prout",?n,?j))
|- pointer(?x,?t,?v)
without
  ?p=?x
if
| pointer(?p,pointer_type(pointer_type(integer_type())),field(numeric_const("0"),?vp))
* pointer(builtin_plus(?p,numeric_const("1")),pointer_type(pointer_type(named_type("struct.prout"))),field(numeric_const("1"),?vp))
* !eltptr(?x,builtin_plus(?p,?n),?j) |- pointer(?x,?t,?v)


/* the struct prout was already unfolded */
rule prout_getelementptr_deref20:
| pointer(?p,pointer_type(pointer_type(integer_type())),?vp)
* !eltptr(?x,?p,jump_named("struct.prout",numeric_const("0"),?j))
|- pointer(?x,?t,?v)
without
  ?p=?x
if
| pointer(?p,pointer_type(pointer_type(integer_type())),?vp)
* !eltptr(?x,?p,?j) |- pointer(?x,?t,?v)

rule prout_getelementptr_deref21:
| pointer(builtin_plus(?p,numeric_const("1")),pointer_type(pointer_type(named_type("struct.prout"))),?vp)
* !eltptr(?x,?p,jump_named("struct.prout",numeric_const("1"),?j))
|- pointer(?x,?t,?v)
without
  ?p=?x
if
| pointer(builtin_plus(?p,numeric_const("1")),pointer_type(pointer_type(named_type("struct.prout"))),?vp)
* !eltptr(?x,builtin_plus(?p,numeric_const("1")),?j) |- pointer(?x,?t,?v)
*/

/* rules for rebuilding a malloc block */
rule int_to_malloc:
| malloced(?mb, integer_type()) * pointer(?mb,pointer_type(integer_type()),?v)
|- malloc_block(?mb)
if
malloced(?mb, integer_type()) * pointer(?mb,integer_type(),?v) | |-

rule prout_to_malloc:
| malloced(?mb, named_type("struct.prout"))
* pointer(?mb,pointer_type(named_type("struct.prout")),?sp)
* pointer(?sp,named_type("struct.prout"),?v)
|- malloc_block(?mb)
if
  malloced(?mb, named_type("struct.prout"))
* pointer(?mb,pointer_type(named_type("struct.prout")),?sp)
* pointer(?sp,named_type("struct.prout"),?v)
| |-

rule unfolded_prout_to_malloc:
| malloced(?mb, named_type("struct.prout"))
* pointer(?mb,pointer_type(named_type("struct.prout")),?sp)
* pointer(?sp,pointer_type(pointer_type(integer_type())),?v0)
* pointer(builtin_plus(?sp,numeric_const("1")),pointer_type(pointer_type(named_type("struct.prout"))),?v1)
|- malloc_block(?mb)
if
  malloced(?mb, named_type("struct.prout"))
* pointer(?mb,pointer_type(named_type("struct.prout")),?sp)
* pointer(?sp,pointer_type(pointer_type(integer_type())),?v0)
* pointer(builtin_plus(?sp,numeric_const("1")),pointer_type(pointer_type(named_type("struct.prout"))),?v1)
| |-



rewrite data_field_of_prout:
  field(numeric_const("0"),struct(?data,?next)) = ?data

rewrite next_field_of_prout:
  field(numeric_const("1"),struct(?data,?next)) = ?next

rewrite sizeof_prout:
  sizeof(named_type("struct.prout")) = numeric_const("8")

rewrite sizeof_int:
  sizeof(integer_type()) = numeric_const("4")

rule jump_end_eq:
| !eltptr(?x,?y,jump_end()) |-
if
| ?x = ?y |-

/*
  If you have a pointer for the same object 
  on both sides of an implication, add the 
  pointer to the matched pointers, and require 
  that proof obligation that there values 
  are the same.  

  The "without" clause prevents the matching
  if we already know the pointers have different 
  values.  
 */
rule pointer_remove1:
| pointer(?x,?t,?v) |-  pointer(?x,?t,?w)
without
  ?v!=?w
if
  pointer(?x,?t,?v) | |- ?v=?w


/*************************************
 * rules for contradictions 
 *************************************/

/*
  If two pointers for the same object with the 
  same name exists in an assumption, then there
  is a contradiction and the proof is complete.
 */ 
rule pointer_pointer_contradiction1 :
  pointer(?x,?t,?v) * pointer(?x,?u,?w) | |- 
if

/*
  If we have an assumption of a pointer, root, or parent
  for null then we have a contradiction.
 */
rule pointer_nil_contradiction : 
  pointer(nil(),?t,?v) | |- 
if


/**************************************
 *  Rules for failed proofs
 **************************************/

/*
  If we need to prove that pointer exists for null
  then we are going to fail, unless we can find 
  a contradiction.
 */
rule pointer_nil_failed :
  | |- pointer(nil(),?t,?v) 
if
  | |- pointer(nil(),?t,?v) * False

/*
  If we need to match two pointers which have 
  distinct values or types, then we need to search for a 
  contradiction (False).
 */
/*
rule pointer_pointer_no_match : 
  | ?y!=?t * pointer(?r,?x,?f,?y) |-  pointer(?s,?x,?g,?t) 
if
  | ?y!=?t * pointer(?r,?x,?f,?y) |-  pointer(?s,?x,?g,?t) * False

rule pointer_types_no_match : 
  | ?f!=?g * pointer(?r,?x,?f,?y) |-  pointer(?s,?x,?g,?t) 
if
  | ?f!=?g * pointer(?r,?x,?f,?y) |-  pointer(?s,?x,?g,?t) * False
*/


rule pointer_not_null :
  pointer(?x,?t,?v) | |- ?x!=nil()
if
  | |-
