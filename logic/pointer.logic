/*************************************
 * Simple subtraction rules 
 *************************************/

rewrite rewrite_zeroinit:
  zeroinitializer() = numeric_const("0")

equiv eq_pred:
 builtin_eq(?x,?y) = numeric_const("0") <=> ?x != ?y
without ?x != ?y

equiv neq_pred:
 builtin_eq(?x,?y) != numeric_const("0") <=> ?x = ?y
without ?x = ?y

/*
  If you have a pointer for the same object 
  on both sides of an implication, add the 
  pointer to the matched pointers, and require 
  that proof obligation that there values 
  are the same.  

  The "without" clause prevents the matching
  if we already know the pointers have different 
  values.  
 */
rule pointer_remove1:
| pointer(?x,?t,?v) |-  pointer(?x,?t,?w)
without
   ?v != ?w
if
  pointer(?x,?t,?v) | |- ?v=?w

rule ptr_collate:
  | pointer(?x,?sz1,?v1) * pointer(builtin_plus(?x, ?sz1),?sz2,?v2)
  |- pointer(?x,?tz,?w)
if
  | pointer(?x,builtin_plus(?sz1, ?sz2),collate(?v1,?v2))
  |- !GT(?tz,?sz1) * pointer(?x,?tz,?w)

rule ptr_collate_plus:
  | pointer(builtin_plus(?x,?n),?sz1,?v1) * pointer(builtin_plus(?x, ?m),?sz2,?v2)
  |- pointer(builtin_plus(?x,?n),?tz,?w)
if
  | pointer(builtin_plus(?x,?n),builtin_plus(?sz1, ?sz2),collate(?v1,?v2))
  |- !GT(?tz,?sz1) * builtin_plus(?n,?sz1) = ?m * pointer(builtin_plus(?x,?n),?tz,?w)

equiv pointer_getelementptr0:
  !eltptr(?x,pointer_type(?gept),?p,jump(numeric_const("0"),?j))
  <=> !eltptr(?x,?gept,?p,?j)

equiv pointer_getelementptr_void:
  !eltptr(?x,pointer_type(integer_type("8")),?p,jump(?n,?j))
  <=> !eltptr(?x,pointer_type(integer_type("8")),builtin_plus(?p,?n),?j)

equiv jump_end:
  !eltptr(?x,?t,?y,jump_end()) <=> ?x = ?y

/*
rule ptr_same_root:
 | pointer(?x,builtin_plus(?tz, ?z),?v) |- pointer(?x,?tz,?w)
if
 pointer(?x,?tz,?w) | pointer(builtin_plus(?x,?tz),?z,rg(?tz,?sz,?v))
 |- ?w = rg(nil(),?tz,?v)
*/

rule ptr_same_root_same_size:
 | pointer(?x,?sz,?v) |- pointer(?x,?tz,?w)
without
  ?sz = numeric_const("16")
* ?tz = numeric_const("8")
|| 
  ?sz = numeric_const("4")
* ?tz = numeric_const("8")
if
 pointer(?x,?tz,?w) |
 |- ?w = ?v * ?sz = ?tz

rule ptr_same_root:
 | pointer(?x,?sz,?v) |- pointer(?x,?tz,?w)
if
 pointer(?x,?tz,?w) | pointer(builtin_plus(?x,?tz),?z,rg(?tz,?sz,?v))
 |- ?w = rg(nil(),?tz,?v) * ?sz = builtin_plus(?tz,?z) * !GT(?sz,?tz)

rule ptr_rule1:
  | pointer(?x,?sz1,?v1) * pointer(builtin_plus(?x, ?sz1),?sz2,?v2)
  |- pointer(builtin_plus(?x, ?n),?tz,?w)
if
  | pointer(?x,builtin_plus(?sz1, ?sz2),collate(?v1,?v2))
  |- !GT(builtin_plus(?x,?sz1),builtin_plus(?x,?n))
   * !GT(builtin_plus(builtin_plus(?x,?n),?tz),builtin_plus(?x,?sz1))
   * pointer(builtin_plus(?x,?n),?tz,?w)

rule ptr_shift_mid:
  | pointer(?x,?sz,?v)
  |- pointer(builtin_plus(?x,?n),?tz,?w)
without ?n = nil()
if
  pointer(builtin_plus(?x,?n),?tz,?w) |
   pointer(?x,?n,rg(nil(),?n,?v))
 * pointer(builtin_plus(builtin_plus(?x,?n),?tz),?z,rg(builtin_plus(?n,?tz),?sz,?v))
  |- !GT(builtin_plus(?x,?sz),builtin_plus(builtin_plus(?x,?n),?tz))
   * builtin_plus(builtin_plus(?n,?tz),?z) = ?sz

rule remove_malloced:
| malloced(?mb, ?n)
|- malloced(?mb,?m)
if
malloced(?mb,?n)| |- ?n = ?m



/*************************************
 * rules for contradictions 
 *************************************/

/*
  If two pointers for the same object with the 
  same name exists in an assumption, then there
  is a contradiction and the proof is complete.
 */ 
rule pointer_pointer_contradiction1 :
  | pointer(?x,?t,?v) * pointer(?x,?u,?w) * ?t != nil() * ?u != nil() |- 
if

/*
  If we have an assumption of a pointer, root, or parent
  for null then we have a contradiction.
 */
rule pointer_nil_contradiction0 : 
  pointer(nil(),?t,?v) | |- 
if


/**************************************
 *  Rules for failed proofs
 **************************************/

/*
  If we need to prove that pointer exists for null
  then we are going to fail, unless we can find 
  a contradiction.
 */
rule pointer_nil_failed :
  | |- pointer(nil(),?t,?v) 
if
  | |- pointer(nil(),?t,?v) * False

/*
  If we need to match two pointers which have 
  distinct values or types, then we need to search for a 
  contradiction (False).
 */
/*
rule pointer_pointer_no_match : 
  | ?y!=?t * pointer(?r,?x,?f,?y) |-  pointer(?s,?x,?g,?t) 
if
  | ?y!=?t * pointer(?r,?x,?f,?y) |-  pointer(?s,?x,?g,?t) * False

rule pointer_types_no_match : 
  | ?f!=?g * pointer(?r,?x,?f,?y) |-  pointer(?s,?x,?g,?t) 
if
  | ?f!=?g * pointer(?r,?x,?f,?y) |-  pointer(?s,?x,?g,?t) * False
*/


rule pointer_not_null :
  pointer(?x,?t,?v) | |- ?x!=nil()
if
  | |-
