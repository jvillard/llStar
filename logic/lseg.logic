import "pointer.logic";

/***************************************
 *  This file defines 
 *
 *  node
 *  ls
 *  lspe
 *
 ***************************************/



rule node_not_nil:
  node(?s,numeric_const("0"),?y) | |-
if

rule lseg_ne_not_nil:
  lseg_ne(?s,numeric_const("0"),?y) | |-
if

rule lseg_not_nil:
  lseg(?s,numeric_const("0"),?y) | |-
if
  | ?y=numeric_const("0") |-


rule node_not_nil:
  node(?s,?x,?y) | |- ?x!=numeric_const("0")
if
  | |-

rule node_not_eq:
  node(?s,?x,?y) * node(?s,?x,?w) | |-
if




/*************************************
 * Rule for unpacking Nodell 
 *
 *  These rules could potentially cycle forever
 *  but due to their order cannot.
 *************************************/

/*
//Unroll node if we are looking for its next field
rule field_remove1a:
  |   node(?s,?x,?e1) |-  field(?x,"<node: node next>",?e2) 
if
  field(?x,"<node: node next>",?e1) | field(?x,"<node: java.lang.String content>",_w) 
     |-  ?e1=?e2 

//Unroll node if we are looking for its content field
rule field_remove1b:
  | node(?s,?x,?e1) |- field(?x,"<node: java.lang.String content>",?e2) 
if
  field(?x,"<node: java.lang.String content>",w) |  field(?x,"<node: node next>",?e1)
     |-  w=?e2


//Roll up a complete node if we have both fields.
rule field_remove2:
  | field(?x,"<node: node next>",?e1) * field(?x,"<node: java.lang.String content>",?z) |- 
if
  | node(?s,?x,?e1) |-  
*/




/*************************************
 * Simple subtraction rules 
 *************************************/


rule lseg_ne_unroll_exists :
| lseg_ne(?s,?x,?y) |- pointer(?x,?w,?Z)
if
| node(?s,?x,_fooz) * lseg(?s,_fooz,?y)  |- pointer(?x,?w,?Z)



rule lseg_ne_lseg_ne_match :
  lseg_ne(?s,?z,?w) | lseg_ne(?s,?x,?y) |- lseg_ne(?s,?x,?z)
if
  lseg_ne(?s,?x,?y) | |- lseg(?s,?y,?z)

rule lseg_ne_node_match :
  node(?s,?z,?w) | lseg_ne(?s,?x,?y) |- lseg_ne(?s,?x,?z)
if
  lseg_ne(?s,?x,?y) | |- lseg(?s,?y,?z)

rule lseg_ne_pointer_match :
  pointer(?z,?f,?w) | lseg_ne(?s,?x,?y) |- lseg_ne(?s,?x,?z)
if
  lseg_ne(?s,?x,?y) | |- lseg(?s,?y,?z)

rule lseg_nil_match :
  | lseg_ne(?s,?x,?y) |- lseg_ne(?s,?x,?z)
if
  lseg_ne(?s,?x,?y) | |- lseg(?s,?y,?z) * ?z = numeric_const("0")



rule nl_lseg_ne_match :
  lseg_ne(?s,?z,?w) | node(?s,?x,?y) |- lseg_ne(?s,?x,?z)
if
  node(?s,?x,?y) | |- lseg(?s,?y,?z)

rule nl_node_match :
  node(?s,?z,?w) | node(?s,?x,?y) |- lseg_ne(?s,?x,?z)
if
  node(?s,?x,?y) | |- lseg(?s,?y,?z)

rule nl_pointer_match :
  pointer(?z,?f,?w) | node(?s,?x,?y) |- lseg_ne(?s,?x,?z)
if
  lseg_ne(?s,?x,?y) | |- lseg(?s,?y,?z)




rule lseg_left :
  | lseg(?s,?x,?y) |- 
if
  | lseg_ne(?s,?x,?y) |- ;
  | ?x=?y |- 


rule lseg_right :
  | |- lseg(?s,?x,?y) 
if
  | |- lseg_ne(?s,?x,?y) 
or
  | |- ?x=?y 


/*************************************
 * rules for contradictions 
 *************************************/
rule lseg_ne_pointer_contradiction:
lseg_ne(?s,?x,?t) * pointer(?x,?sz,?z) | |- 
if

rule lseg_ne_node_contradiction :
lseg_ne(?s,?x,?t) * node(?ss,?x,?z) | |- 
if

rule lseg_ne_lseg_ne_contr :
lseg_ne(?s,?x,?t) * lseg_ne(?ss,?x,?z) | |-
if

rule lseg_ne_lseg_ne_contr :
 | |- lseg_ne(?s,?x,?t) * lseg_ne(?ss,?x,?z)
if
 | |- x!=x 
